export const summary: String =
  "## Bit Manipulation Playlist: Single Number Part III\n\nWelcome back to our **Bit Manipulation** series. Today, we're tackling **Single Number Part III**. If you've missed the earlier parts, I recommend checking them out first.\n\n### Problem Statement\n\nGiven an array `nums` where every element appears twice except for two distinct numbers which appear only once, your task is to find these two numbers.\n\n### Example\n\n- Input: `nums = [2, 2, 3, 3, 7, 7, 4, 6]`\n- Output: `[4, 6]` (Order does not matter)\n\n### Solution Approach\n\n#### Hashing\n\n1. Use a map to track the frequency of each number.\n2. Iterate through `nums`, updating the map.\n3. Traverse the map to find numbers with a frequency of 1.\n\n#### Optimized Approach Using Bitwise Operators\n\n1. **Initial XOR**: XOR all numbers to find the XOR of the two unique numbers.\n2. **Find Different Bit**: Identify a bit where the two numbers differ.\n3. **Bucketing**: Separate numbers based on the identified bit.\n4. **Final XOR**: XOR numbers in each bucket to isolate the unique numbers.\n\n### Pseudo Code\n\n```python\nxor_all = 0\nfor num in nums:\n    xor_all ^= num\n\nrightmost_bit = xor_all & -xor_all\nunique1, unique2 = 0, 0\n\nfor num in nums:\n    if num & rightmost_bit:\n        unique1 ^= num\n    else:\n        unique2 ^= num\n\nreturn [unique1, unique2]\n```\n\n\n### Complexity Analysis\n\n- **Time Complexity**: O(N), where N is the number of elements in `nums`.\n- **Space Complexity**: O(1), as we use only constant extra space.\n\n### Key Takeaways\n\n- This approach leverages bitwise operations to efficiently solve the problem without additional data structures.\n- The concept of bucketing based on differing bits is crucial for separating the unique numbers.\n";
